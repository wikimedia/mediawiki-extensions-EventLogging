#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  json2sql
  --------
  Consume JSON event stream into MySQL

  usage: json2sql [-h] [--sid SID] input db

  positional arguments:
    input       URI of JSON event stream to consume
    db          URI of DB to write to

  optional arguments:
    -h, --help  show this help message and exit
    --sid SID   set input socket identity

  :copyright: (c) 2012 by Ori Livneh <ori@wikimedia.org>
  :license: GNU General Public Licence 2.0 or later

"""
import argparse
import logging
import sys
from datetime import datetime

from sqlalchemy import types, MetaData, Column, Table
from sqlalchemy.exc import SQLAlchemyError, NoSuchTableError

from eventlogging.compat import items
from eventlogging.schema import get_schema
from eventlogging.stream import zmq_subscribe


parser = argparse.ArgumentParser(
    description='Consume JSON event stream into MySQL')
parser.add_argument('input', help='URI of JSON event stream to consume')
parser.add_argument('db', help='URI of DB to write to')
parser.add_argument('--sid', help='set input socket identity')
args = parser.parse_args()


META_PROPERTIES_SCHEMA = 4933665

table_name_format = '{name}_{rev}'

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

meta = MetaData(args.db)

# Mapping of JSON schema types to SQL types:
sql_types = {
    'boolean': types.Boolean,
    'integer': types.Integer,
    'number': types.Float,
    'string': types.String(255),
}


def generate_column(name, descriptor):
    """Create a column from a JSON Schema property specifier."""
    json_type = descriptor['type']
    sql_type = sql_types.get(json_type, sql_types['string'])
    if 'timestamp' in name:
        sql_type = types.DateTime
    nullable = not descriptor.get('required', False)
    return Column(name, sql_type, nullable=nullable)


def get_table(name, rev):
    """Loads or creates a table for a given schema name and revision."""
    table_name = table_name_format.format(name=name, rev=rev)
    try:
        return Table(table_name, meta, autoload=True)
    except NoSuchTableError:
        return create_table(name, rev)


def create_table(name, rev):
    """Creates a table for a given schema name and revision."""
    schema_self = get_schema(rev)
    schema_meta = get_schema(META_PROPERTIES_SCHEMA)

    # Every table gets an int auto-increment primary key:
    columns = [Column('id', types.Integer, primary_key=True)]

    for schema in (schema_self, schema_meta):
        properties = schema['properties']
        columns.extend(generate_column(k, v) for k, v in items(properties))

    table_name = table_name_format.format(name=name, rev=rev)
    table = Table(table_name, meta, *columns)
    table.create()
    return table


def store_event(event):
    # Gross: we special-case keys with 'timestamp' in their name and
    # force their type to be datetime. TODO(ori-l, 28-Dec-2012): Use
    # JSON Schema's 'format'.
    event.update({('_' + k): v for k, v in items(event.pop('_meta'))})
    for key in event:
        if 'timestamp' in key:
            event[key] = datetime.fromtimestamp(int(event[key]))

    try:
        table = get_table(event['_schema'], event['_revision'])
    except Exception:
        logging.exception('Unable to get or set suitable table')
    else:
        table.insert(values=event).execute()


sub = zmq_subscribe(args.input, sid=args.sid, json=True)
while 1:
    try:
        ev = next(sub)
        logging.info(ev)
        store_event(ev)
    except SQLAlchemyError:
        logging.exception('Unable to insert event: %s', ev)
