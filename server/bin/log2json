#!/usr/bin/env python
# -*- coding: utf8 -*-
"""
  log2json
  --------
  Transform raw log stream to JSON event stream

  usage: log2json [-h] [--sid SID] input output

  positional arguments:
    input       URI of raw input stream
    output      URI of output stream

  optional arguments:
    -h, --help  show this help message and exit
    --sid SID   set input socket identity

  :copyright: (c) 2012 by Ori Livneh <ori@wikimedia.org>
  :license: GNU General Public Licence 2.0 or later

"""
from __future__ import unicode_literals

import argparse
import logging
import sys

import jsonschema
import zmq

from eventlogging.compat import json, items, unquote_plus
from eventlogging.schema import get_schema
from eventlogging.stream import zmq_subscribe
from eventlogging.utils import ncsa_to_epoch, hash_value


logging.basicConfig(level=logging.DEBUG, stream=sys.stderr)

ap = argparse.ArgumentParser(description='Raw log -> JSON stream')
ap.add_argument('input', help='URI of raw input stream')
ap.add_argument('output', help='URI of output stream')
ap.add_argument('--sid', help='set input socket identity')
args = ap.parse_args()

meta_schema = get_schema(5017149)

migrations = {
    'valid': 'isValid',
}


def migrate_metadata(meta):
    """
    Homogenize events generated by older (but potentially still
    deployed) JavaScript code to the most recent schema.

    The idea is to box ad-hoc processing of events (with an eye toward
    its elimination) rather than pollute the entire codebase.
    """
    migrated = {}
    for key, val in items(meta):
        key = key.strip('_')
        key = migrations.get(key, key)
        migrated[key] = val
    return migrated


def decode_client_event(q):
    """
    Decodes a query string containing a single URL-encoded
    JSON-serialized event and validates it.
    """
    q, origin, seq_id, timestamp, client_ip = q.split()

    q = unquote_plus(q.strip('?;'))
    e = json.loads(q)

    # Extract the nested 'meta' dict, migrate it to the latest format,
    # validate it, and re-inject it into the event:

    meta_key = next(k for k in e if 'meta' in k)
    meta = e.pop(meta_key)

    meta = migrate_metadata(meta)
    meta.update({
        'isTruncated': not q.endswith(';'),
        'origin': origin.split('.', 1)[0],
        'seqId': int(seq_id),
        'timestamp': ncsa_to_epoch(timestamp),
        'clientIp': hash_value(client_ip)
    })
    jsonschema.validate(meta, meta_schema)

    schema = get_schema(meta['revision'])
    jsonschema.validate(e, schema)

    e['_meta'] = meta
    return e


if __name__ == '__main__':
    context = zmq.Context.instance()
    pub = context.socket(zmq.PUB)
    pub.bind(args.output)

    logging.info('Publishing JSON events on %s.', args.output)

    for raw_event in zmq_subscribe(args.input, sid=args.sid):
        try:
            event = decode_client_event(raw_event)
        except (ValueError, KeyError, jsonschema.ValidationError):
            logging.exception('Unable to decode: %s', raw_event)
        else:
            pub.send_unicode(json.dumps(event) + '\n')
